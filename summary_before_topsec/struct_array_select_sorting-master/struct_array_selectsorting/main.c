#include <stdio.h>

struct Student
{
    int num;
    char name[20];
    float score;
};

int main()
{
    struct Student stu[5]={{10101,"zhang",78},{10106,"wang",98.5},{10106,"li",86},{10108,"ling",73.5},{10110,"sun",100}};
    struct Student temp;
    const int n=5;
    int i,j,k,y;
    printf("The order is: \n");
    for(i=0;i<n;i++)
    {
        k=i;
        for(j=i+1;j<n;j++)
            if (stu[j].score > stu[k].score)
                k = j;              //交换，k,j,

            temp = stu[k];
            stu[k] = stu[i];
            stu[i] = temp;
//            printf("%6d %8s %6.2f\n",stu[4].num,stu[4].name,stu[4].score);
            for(y=0;y<n;y++)
                printf("%6d %8s %6.2f\n",stu[y].num,stu[y].name,stu[y].score);
    }
//    for(i=0;i<n;i++)
//        printf("%6d %8s %6.2f\n",stu[i].num,stu[i].name,stu[i].score);
    printf("\n");
    return 0;
}

/* 可以在第二个for循环最后加上如下的代码，可以输出程序执行过程中的数组的顺序（未完成的顺序）
 * for(y=0;y<n;y++)
                printf("%6d %8s %6.2f\n",stu[y].num,stu[y].name,stu[y].score);
上面这条语句会打印出每次的顺序，这个顺序是在程序内部改变的，外部还是之前的样子！
 *
 *
 *  1)   78   98.5    86  73.5    100
 *  ============
 *  i=0 i<4
 *  k=0
 *  ---------------
 *  j=1 j<5
 *  stu[1]>stu[0] //再跟第1位元素相比
 *  98.5 > 78
 *  k=1 ***
 *  temp = 98.5
 *  stu[k] = stu[i]=78
 *  i = temp =98.5
 *  ----------------
 *  j=2 j<5
 *  stu[2]>stu[1]  (k=1)再跟第2位元素相比
 *  86 > 98.5
 *  k=1
 *  -----------------
 *  j=3 j<5
 *  stu[3]>stu[1]
 *  73.5 > 98.5
 *  k=1
 *  ------------------
 *  j=4 j<5
 *  stu[4]>stu[1]
 *  100 > 98.5
 *  k=4=j ***
 *  temp = 100
 *  stu[k] = stu[0]=78
 *  stu[i] = temp =100
 *===============================
 *  2）数组的顺序就变成如下：
 *  100  98.5    86  73.5    78
 *  i=1 i<4
 *  k=1
 *  ---------------
 *  j=2 j<5
 *  stu[2]>stu[i] k=i=1 //再跟第2位元素相比
 *  86 > 98.5  **不执行
 *  k=1 ***
 *  -----------------------
 *  j=3 j<5
 *  stu[3]>stu[i] k=i=1
 *  73.5 > 98.5  **不执行
 *  k=1 ***
 *  ------------------------
 *  j=4 j<5
 *  stu[4]>stu[i] k=i=1
 *  78 > 98.5  **不执行
 *  k=1 ***
 *  ------------------------
 *  stu[i]=stu[1]=98.5
 *=================================
 *  3）数组的顺序：
 *  100  98.5    86  73.5    78
 *  i=2 i<4
 *  k=2
 *  ---------------
 *  j=3 j<5
 *  stu[3]>stu[i] k=i=2//再跟第3位元素相比
 *  73.5 > 86  **不执行
 *  k=2 ***
 *  -----------------------
 *  j=4 j<5
 *  stu[4]>stu[2] k=i=2
 *  78 > 86  **不执行
 *  k=2 ***
 *  ------------------------
 *  stu[i]=stu[2]=86
 * ============================
 * 4）数组的顺序：
 *  100  98.5    86  73.5    78
 *  i=3 i<4
 *  k=3
 *  ---------------
 *  j=4 j<5
 *  stu[4]>stu[3] k=i=3//再跟第4位元素相比
 *  78 > 73.5
 *  k=4
 *  temp = stu[4]=78 //k=4
 *  stu[4] = stu[i]=73.5 //i=3
 *  stu[i] = temp =78
 *  stu[i]=stu[3]=78
 * ===========================
 *  最终数组的顺序：
 *  100  98.5    86  78 73.5
 *
 *
 *
 * ===========================
 *
 * 直接排序
 *
 *
 *
 * 直接选择排序（Selection Sorting）的基本思想是在第i次选择操作中，
 *
 *
 *
 * 通过n-i次键值比较，从n-i+1个记录中选出最小的记录，并和第i(1<=i<=n-1)个记录交换。

  初始序列：{45 38 66 90 88 10 25}

  第一步共有7个数，所以n=7，首先另i=1这时候需要通过6次键值比较，从7个记录中选出最小记录，

  并和第1个记录交换得到{10 38 66 90 8845 25}

  第二步另i=2，这时候我们需要通过六次比较，从剩余6个记录中选出最小记录，并和第2个记录交换得到{1025 66 90 88 45 38}

  第三步i=3,从剩余的5个记录中找到最小记录，并和第3个记录交换得到{10 2538 90 88 45 66}

  第四步i=4,从剩余的4个记录中找到最小记录，并和第4个记录交换得到{10 25 3845 88 90 66}

  第五步i=5,从剩余的3个记录中找到最小记录，并和第5个记录交换得到{10 25 38 456690 88}

  第六步i=6,从剩余的2个记录中找到最小记录，并和第6个记录交换得到{10 25 38 456688 90}

  此时得到最终有序数列。

  算法描述：
    <span style="font-family:KaiTi_GB2312;font-size:18px;">        void SelectSort(List R,int n)
        {
            int min, i, j;
            for(i=1;i<=n-1;i++)//每次循环选择出最小一个键值
            {
                min=i;//假设第i个记录键值最小
                for(j=i+1;j<=n;j++)
                {
                    if(R[j].key<R[min].key) min =j;//记录下键值最小记录的下标
                    if(min!=i) swap(R[min],R[i]);//将最小键值记录和第i个记录交换
                }
            }
        }</span>
 *
 *
 * */